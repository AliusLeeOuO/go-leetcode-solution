package solution

func SingleNumber(nums []int) int {
	/*
		异或运算（XOR，符号为 ^）是一种基于位的运算，遵循以下基本规则：

		如果两个比较的位相同，则结果为0。
		如果两个比较的位不同，则结果为1。
		这意味着对于任何两个数字的异或运算，你需要按照它们的二进制表示进行逐位比较。

		让我们拿数字4和1的异或操作作为例子，来详细解释这个过程：

		首先，我们写出它们的二进制形式。数字4在二进制中是100，数字1在二进制中是001。
		然后，我们逐位进行比较并应用上面的规则：

		  100
		^ 001
		-----
		  101

		在最高位（左边起第一位），4有一个1，而1在这一位是0，因此根据规则2，结果是1。
		在中间位，4的位是0，1的位也是0，根据规则1，结果是0。
		在最低位（右边起第一位），4的位是0，而1的位是1，根据规则2，结果是1。
		所以，4 ^ 1 = 101（二进制），转换回十进制就是5。

		这个过程可以用来解释任何两个数字的异或运算。异或运算的一些特性包括：

		任何数和0进行异或运算结果不变，即a ^ 0 = a。
		任何数和其自身进行异或运算结果为0，即a ^ a = 0。
		异或运算满足交换律和结合律，即a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c，
		这使得多个数的异或运算的顺序可以任意调换。
		这就是为什么在你的例子中，4 ^ 1 ^ 2 ^ 1 ^ 2最终结果是4，
		因为所有成对的数字通过异或操作都会相互抵消变为0，剩下的就是那个唯一的没有成对的数字。

	*/
	r := 0
	for _, num := range nums {
		r ^= num
	}
	return r
}
